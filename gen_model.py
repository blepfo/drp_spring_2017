"""Superclass for generative models used in a Jupyter Notebook. """

import tensorflow as tf
import numpy as np
from math import floor
from math import sqrt
from matplotlib import pyplot as plt
from matplotlib.gridspec import GridSpec

class Gen_Model:
	"""Generative Model superclass.
	
	Generative model must override __init__() and implement train() to be useful.
	Functions in this superclass are mostly to enable easy use of generative models
	in a Jupyter Notebook or other interactive shell. 
	
	Attributes:
		latent_samples (tf placeholder): TF Placeholder to input latent samples
		generated (tensor): Tensor output generated by the model
		sess (tf session): Interactive session created with begin_session()
		graph (tensorflow graph): Must be created in __init__ function of subclass
	"""

	def __init__(self, name):
		"""Constructor.
		
		Must be overloaded in subclasses to construct TensorFlow graph for the model. 
		
		Args: 
			name (string): name for the network
		"""
		self.name = name
		
	def begin_session(self):
		"""Launch the model's graph in an interactive TensorFlow session. """
		self.sess = tf.InteractiveSession(graph=self.graph)
		self.sess.run(tf.global_variables_initializer())
		
	def save(self, save_dir=None, step=None):
		"""Save the model's session.
		
		Args:
			save_dir (string): Path to directory where model should be saved. 
			step (int): What batch/epoch the model is being saved at.
		"""
		if save_dir == None:
			save_dir = self.save_dir
		tf.train.Saver().save(self.sess, save_dir, global_step=step)
	
	def restore(self, save_dir=None):
		"""Restore model 
		
		Args:
			save_dir (string): Path to where the model has been saved.	
		"""
		if save_dir == None:
			save_dir = self.save_dir
		tf.train.Saver().restore(self.sess, save_dir)
		
	def end_session(self):
		""" Close the model's interactive session """
		self.sess.close()
		self.sess = None	
	
	def __str__(self):
		"""Return string with all trainable variables in the network."""
		with self.graph.as_default():
			return "\n".join([var.name for var in tf.trainable_variables()])
		
	def generate(self):
		""" Generate 3 samples and display in a row 
	
		For now, this is setup to work with generated MNIST samples
		"""
		samples = np.random.randn(3, self.hidden_dim)
		images = self.sess.run(self.generated, feed_dict={self.latent_samples : samples})
		for i in range(3):
			plt.subplot(1, 3, i + 1)
			plt.imshow(np.reshape(images[i], [28,28]), cmap="Greys")
			plt.axis('off')
		plt.show()
		
	def visualize_latent2D(self, size=81, low=-0.5, high=0.5, save=False, save_dir=None, name=None):
		""" Display grid of images created by selecting 2D latent vectors from a grid.
		
		Requires that the hidden dimension of the network be 2. 2D latent vectors 
		are sampled from a uniform distribution. 
		
		Args:
			size (int): Number of images to be created. Must be a perfect square.
			low (float): Lower bound on interval to draw latent samples from.
			high (float): Upper bound on interval to draw latent samples from. 
		
		"""
		if self.hidden_dim != 2:
			raise Exception("Model needs 2D latent dimension to use visualize_latent2D()")
		# Create images
		latent_samples = np.matrix([[x, y] for x in np.linspace(low, high, size) 
										for y in np.linspace(low, high, size)])
		images = self.sess.run(self.generated, feed_dict={self.latent_samples : latent_samples})
		square_size = floor(sqrt(size))
		fig = plt.figure(figsize=(square_size, square_size))
		for i in range(1, size + 1):
			plt.subplot(square_size, square_size, i)
			plt.imshow(np.reshape(images[i], [28, 28]), cmap="Greys")
			plt.axis('off')
		fig.subplots_adjust(wspace=0, hspace=0)
		if save:
			fig.savefig("%s%s" % (save_dir, name), bbox_inches='tight')
			plt.close()
		else:
			plt.show()